-- Oracle 1일차
-- 제약조건 없는 데이블
CREATE TABLE USER_NO_CONSTRAINT(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(30),
    USER_NAME VARCHAR2(30),
    USER_GENDER VARCHAR2(10),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50)
);

DESC USER_NO_CONSTRAINT;

INSERT INTO USER_NO_CONSTRAINT
VALUES(1, 'olauser01', 'pass01', '일용자', '남', '01012341234', 'olauser01@ola.com');
INSERT INTO USER_NO_CONSTRAINT
VALUES(2, 'olauser02', 'pass02', '이용자', '남', '01012341234', 'olauser02@ola.com');
INSERT INTO USER_NO_CONSTRAINT
VALUES(3, null, 'pass03', '삼용자', '남', '01012341234', 'olauser03@ola.com');

SELECT * FROM USER_NO_CONSTRAINT;

DELETE FROM USER_NO_CONSTRAINT WHERE USER_NO = 1;

-- NOT NULL 제약조건 테이블
CREATE TABLE USER_CONSTRAINT_NOTNULL(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) NOT NULL,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    USER_GENDER VARCHAR2(10),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50)
);

SELECT * FROM USER_CONSTRAINT_NOTNULL;

INSERT INTO USER_CONSTRAINT_NOTNULL
VALUES(1, 'olauser01', 'pass01', '일용자', '남', '01022223333', 'olauser01@ola.com');
INSERT INTO USER_CONSTRAINT_NOTNULL
VALUES(1, null, 'pass01', '일용자', '남', '01022223333', 'olauser01@ola.com');

-- UNIQUE 제약조건 테이블
CREATE TABLE USER_CONSTRAINT_UNIQUE (
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    USER_GENDER VARCHAR2(10),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50)
);

INSERT INTO USER_CONSTRAINT_UNIQUE VALUES(1, 'olauser01', 'pass01', '일용자', '남', '01022223333', 'olauser01@ola.com');
INSERT INTO USER_CONSTRAINT_UNIQUE VALUES(1, 'olauser02', 'pass01', '일용자', '남', '01022223333', 'olauser01@ola.com');
-- UNIQUE 제약조건은 NULL을 허용함.
INSERT INTO USER_CONSTRAINT_UNIQUE VALUES(1, null, 'pass01', '일용자', '남', '01022223333', 'olauser01@ola.com');

SELECT * FROM USER_CONSTRAINT_UNIQUE;

-- PRIMARY KEY 제약조건 테이블
CREATE TABLE USER_PRIMARY_KEY (
    USER_NO NUMBER UNIQUE,
    USER_ID VARCHAR2(20) PRIMARY KEY,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    USER_GENDER VARCHAR2(10),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50)    
);

-- PRIMARY KEY는 중복을 허용하지 않고 NULL도 허용하지 않음.
-- ORA-00001: 무결성 제약 조건(OLAUSER01.SYS_C007397)에 위배됩니다
-- SQL 오류: ORA-01400: NULL을 ("OLAUSER01"."USER_PRIMARY_KEY"."USER_ID") 안에 삽입할 수 없습니다
-- 01400. 00000 -  "cannot insert NULL into (%s)"
INSERT INTO USER_PRIMARY_KEY
VALUES(1, 'olauser01', 'pass01', '일용자', '남', '01012343456', 'olauser01@ola.com');
INSERT INTO USER_PRIMARY_KEY
VALUES(1, null, 'pass01', '일용자', '남', '01012343456', 'olauser01@ola.com');

SELECT * FROM USER_PRIMARY_KEY;

-- CHECK 제약조건 테이블
CREATE TABLE USER_CHECK (
    USER_NO NUMBER UNIQUE,
    USER_ID VARCHAR2(20) PRIMARY KEY,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    USER_GENDER VARCHAR2(10) CHECK(USER_GENDER IN ('M', 'F')),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50)    
);
DROP TABLE USER_CHECK;
-- ORA-02290: 체크 제약조건(OLAUSER01.SYS_C007401)이 위배되었습니다
INSERT INTO USER_CHECK
VALUES(1, 'olauser01', 'pass01', '일용자', '남', '01012343456', 'olauser01@ola.com');
INSERT INTO USER_CHECK
VALUES(1, 'olauser01', 'pass01', '일용자', 'M', '01012343456', 'olauser01@ola.com');

SELECT * FROM USER_CHECK;

-- DEFAULT 제약조건 테이블
-- 기본값을 설정하는 제약조건
CREATE TABLE USER_DEFAULT (
    USER_NO NUMBER UNIQUE,
    USER_ID VARCHAR2(20) PRIMARY KEY,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    USER_GENDER VARCHAR2(10) CHECK(USER_GENDER IN ('M', 'F')),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50),
    USER_DATE DATE DEFAULT SYSDATE, -- 아무것도 입력하지 않으면 이 값이 들어가요
    USER_YN CHAR(1) DEFAULT 'Y' -- 기본값을 설정하는 제약조건
);
INSERT INTO USER_DEFAULT
VALUES(1, 'olauser01', 'pass01', '일용자', 'M', '01012343456', 'olauser01@ola.com', DEFAULT);
SELECT * FROM USER_DEFAULT;

-- FOREIGN KEY 외래키 제약조건
CREATE TABLE USER_GRADE(
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE VALUES(10, '일반회원');
INSERT INTO USER_GRADE VALUES(20, '우수회원');
INSERT INTO USER_GRADE VALUES(30, '특별회원');

SELECT * FROM USER_GRADE;
COMMIT;
--  생성 및 데이터 추가 후 확인해보세요
-- USER_GRADE는 참조될 부모 테이블입니다. 자식테이블의 한 컬럼이 부모컬럼의 데이터르 사용합니다.

CREATE TABLE USER_FOREIGNKEY (
    USER_NO NUMBER UNIQUE,
    USER_ID VARCHAR2(20) PRIMARY KEY,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    USER_GENDER VARCHAR2(10) CHECK(USER_GENDER IN ('M', 'F')),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50),
    USER_DATE DATE DEFAULT SYSDATE, -- 아무것도 입력하지 않으면 이 값이 들어가요
    GRADE_CODE NUMBER REFERENCES USER_GRADE(GRADE_CODE) -- USER_GRADE 테이블에 있는 GRADE_CODE의 값만 쓸거야
    -- GRADE_CODE에 들어갈 수 있는 값은? 10, 20, 30
);
CREATE TABLE USER_FOREIGNKEY (
    USER_NO NUMBER UNIQUE,
    USER_ID VARCHAR2(20) PRIMARY KEY,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    USER_GENDER VARCHAR2(10) CHECK(USER_GENDER IN ('M', 'F')),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50),
    USER_DATE DATE DEFAULT SYSDATE, -- 아무것도 입력하지 않으면 이 값이 들어가요
    GRADE_CODE NUMBER REFERENCES USER_GRADE(GRADE_CODE) ON DELETE CASCADE -- 부모 레코드가 지워질 때 자식레코드도 같이 지워짐
    -- GRADE_CODE에 들어갈 수 있는 값은? 10, 20, 30
);
CREATE TABLE USER_FOREIGNKEY (
    USER_NO NUMBER UNIQUE,
    USER_ID VARCHAR2(20) PRIMARY KEY,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    USER_GENDER VARCHAR2(10) CHECK(USER_GENDER IN ('M', 'F')),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50),
    USER_DATE DATE DEFAULT SYSDATE, -- 아무것도 입력하지 않으면 이 값이 들어가요
    GRADE_CODE NUMBER REFERENCES USER_GRADE(GRADE_CODE) ON DELETE SET NULL -- 부모 레코드가 지워질 때 자식레코드에서 NULL이 됨
    -- GRADE_CODE에 들어갈 수 있는 값은? 10, 20, 30
);
DROP TABLE USER_FOREIGNKEY;
SELECT * FROM USER_FOREIGNKEY;
COMMIT;
INSERT INTO USER_FOREIGNKEY
VALUES(1, 'olauser01', 'pass01', '일용자', 'M', '01012343456', 'olauser01@ola.com', DEFAULT, 10);
INSERT INTO USER_FOREIGNKEY
VALUES(2, 'olauser02', 'pass02', '이용자', 'M', '01012343456', 'olauser01@ola.com', DEFAULT, 20);
INSERT INTO USER_FOREIGNKEY
VALUES(3, 'olauser03', 'pass03', '삼용자', 'M', '01012343456', 'olauser01@ola.com', DEFAULT, 30);
-- 참조 무결성을 보장하는  FOREIGNKEY의 역할
-- 자식 테이블에서 insert할 때, 부모 테이블이 가지고 있는 컬럼의 필드값으로만 insert가 되도록 함.
-- 부모테이블에서는 데이터를 함부로 지우지 못함. -> 왜 그런거에요? 참조 무결성 꺠지지 않기 위해서 지우지 못함.
INSERT INTO USER_FOREIGNKEY
VALUES(4, 'olauser04', 'pass04', '사용자', 'M', '01012343456', 'olauser01@ola.com', DEFAULT, 40);
COMMIT;


-- * 부모레코드를 삭제하려면
-- ORA-02292: 무결성 제약조건(OLAUSER01.SYS_C007426)이 위배되었습니다- 자식 레코드가 발견되었습니다
DELETE FROM USER_GRADE WHERE GRADE_CODE = 10;


-- 1. 자식 레코드를 삭제 후 부모 레코드 삭제 가능
DELETE FROM USER_FOREIGNKEY WHERE GRADE_CODE = 10;
ROLLBACK;
-- 2. 외래키 설정시 삭제 옵션 ON DELETE CASCADE 붙여주기
-- > 부모레코드와 자식레코드 모두 삭제됨.
-- 3. 외래키 설정시 삭제 옵션 ON DELETE SET NULL 붙여주기
-- > 부모레코드 삭제 후 자식레코드에서 참조된 값이 NULL이 됨.

-- 외래키(FOREIGNKEY) 예제
-- SHOP 고객 테이블 (SHOP_MEMBER)
-- USER_NO, USER_ID, USER_PWD, USER_NAME, USER_GENDER, USER_PHONE, USER_EMAIL
-- NUMBER, VARCHAR2(30), VARCHAR2(50), VARCHAR2(20), 
-- 영어 1글자 1바이트, 한글 1글자 3바이트
CREATE TABLE SHOP_MEMBER(
    USER_NO NUMBER UNIQUE,
    USER_ID VARCHAR2(20) PRIMARY KEY,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    USER_GEDNER VARCHAR2(10),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50)
);
INSERT INTO SHOP_MEMBER
VALUES(1, 'olauser01', 'pass01', '일용자', 'M', '01082893933','olauser01@naver.com');
INSERT INTO SHOP_MEMBER
VALUES(2, 'olauser02', 'pass02', '일용자', 'M', '01082893933','olauser02@naver.com');
INSERT INTO SHOP_MEMBER
VALUES(3, 'olauser03', 'pass03', '일용자', 'M', '01082893933','olauser03@naver.com');
-- SHOP 구매내역 테이블 (SHOP_BUY)
-- BUY_NO, USER_ID, PRODUCT_NAME, REG_DATE
-- SHOP 고객에 한해서 물건을 구매할 수 있도록 외래키 제약조건을 설정해보세요
CREATE TABLE SHOP_BUY (
    BUY_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(30) REFERENCES SHOP_MEMBER(USER_ID) ON DELETE SET NULL,
    PRODUCT_NAME VARCHAR2(20),
    REG_DATE DATE DEFAULT SYSDATE
);

INSERT INTO SHOP_BUY
VALUES(1, 'olauser01', '농구화', DEFAULT);
INSERT INTO SHOP_BUY
VALUES(2, 'olauser02', '축구화', DEFAULT);
INSERT INTO SHOP_BUY
VALUES(3, 'olauser03', '배구화', DEFAULT);
INSERT INTO SHOP_BUY
VALUES(4, 'olauser04', '족구화', DEFAULT);

-- 부모 레코드 삭제
-- ON DELETE SET NULL -> 자식레코드에서 참조된 값은 NULL이 된다 OLAUSER01 -> NULL
DELETE FROM SHOP_MEMBER WHERE USER_ID = 'olauser01';

COMMIT;
SELECT * FROM SHOP_MEMBER;
SELECT * FROM SHOP_BUY;

-- UPDATE 복습
SELECT * FROM SHOP_BUY;
-- BUY_NO가 1인 레코드의 USER_ID 값이 NULL
-- NULL -> OLAUSER01로 바꾸기 위한 쿼리문을 작성하시오
UPDATE SHOP_BUY
SET USER_ID = 'olauser01'
WHERE BUY_NO = 1;

ROLLBACK;